<?php
/*
	The DrupalizeClass module.

	Nodebite 2014, Thomas Frank

	This module does nothing in itself.
	It is a  helper module that simplifies listening
	to hooks when you write class based code in other modules

	You can write several classes in your own Drupal module
	and then create objects/instances.

	--------------------------------------------------------------------

	In your classes you can tell one our more methods
	to listen to one or more hooks, by simply using public properties
	that you name like "$methodname_hook_hookname".
	(You don't need to give these properties any value)

	class Dog {

	  public $bark_hook_init;
	  public $bark_hook_boot;
	  public function bark(){...}

	  public $eat_hook_boot;
	  public function eat(){...}

	}

	class Cat {
	  
	 public $meow_hook_init;
	 public function meow();

	}

	The above would cause Dog->bark and Dog>eat to run on hook_boot
	and Dog->bark and Cat->meow to run on hook_init

	--------------------------------------------------------------------

	In your .module file you then need to take the following steps

	1) 	Include your classes (anyway you want)

	2)	Instantiate your classes - create objects
			$dog1 = new Dog(); $dog2 = new Dog(); $cat = new Cat();

	3) 	Tell DrupalizeClass the name of your module
			DrupalizeClass::setModuleName("Animals");

	4) 	Tell DrupalizeClass that your objects should listen to hooks
			DrupalizeClass::regHooks($dog1, $dog2, $cat);

	--------------------------------------------------------------------


*/

class DrupalizeClass {

	private static $moduleName, $hookMem = array();
  

	public static function setModuleName($moduleName){

		self::$moduleName = $moduleName;

	}

	public static function hookLookup($moduleName,$hookName,$args){
		$mem = &self::$hookMem;

		// Don't attempt anything if not registrered properly
		if(!isset($mem[$moduleName]) || !isset($mem[$moduleName][$hookName])){
			return;
		}

		// Call registrered classes and methods
		foreach($mem[$moduleName][$hookName] as $method){
		

			call_user_func_array(
				array($method["obj"],$method["method"]),
				$args
			);
			echo('<br><br>');
			
		}
	}

	public static function regHooks(){
		$objs = func_get_args();
		foreach($objs as $obj){
			self::regHooks2($obj);
		}
	}


	private static function regHooks2(&$obj){

		$moduleName = self::$moduleName;

		$className = get_class($obj);

		$props = array_keys(get_class_vars($className));

		$methods = get_class_methods($obj);

		$mem = &self::$hookMem;

		foreach($methods as $method){

			// Get hooks names for this method
			// (... as indicated by propnames...)
			foreach($props as $prop){
				
				// No indication in this prop so continue
				if(strpos($prop,$method."_hook") !== 0){
					continue;
				}

				// Get the hook name
				$hookName = explode("_hook_",$prop);
				$hookName = array_pop($hookName);

				// Create a memory entry for the module if it is not registrered
				if(!isset($mem[$moduleName])){
					$mem[$moduleName] = array();
				}

				// Create a memory entry for the hook if it is not registrered
				if(!isset($mem[$moduleName][$hookName])){
					$mem[$moduleName][$hookName] = array();
					// Params by ref
					$params = "";
					for($i = 0; $i < 100; $i++){
						$params.= ($i ? ',' : '').'&$param'.$i. ' = null ';
					}
					// And a function for the hook
					eval(
						"function ".$moduleName."_".$hookName.'('.$params.'){'.
						'$argc = func_num_args();$params = array();'.
  						'for ($i = 0; $i < $argc; $i++) {'.
    					'$name = "param".$i;'.
    					'$params[] = & $$name;}'.
						'DrupalizeClass::hookLookup'.
						'("'.$moduleName.'","'.$hookName.'",$params);}'
					);

				}

				// Register this method for a callback
				$mem[$moduleName][$hookName][] = array(
					"obj" => $obj,
					"method" => $method
				);

			}

		}


	}

}

// Set a really low weight for this module
// to make it run first

function your_module_name_install() {
  db_update('system')
    ->fields(array('weight' => -1000))
    ->condition('name', 'drupalize_class', '=')
    ->execute();
}